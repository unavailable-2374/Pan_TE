#!/usr/bin/env perl
use strict;
use warnings;
use Cwd qw(getcwd);
use FindBin;
use lib $FindBin::RealBin;
use File::Path qw(make_path);
use File::Spec;
use Getopt::Long;
use Pod::Usage;
use POSIX qw(:sys_wait_h ceil floor);
use File::Basename;
use Log::Log4perl qw(:easy);

# Configure logging
Log::Log4perl->easy_init({
    level   => $INFO,
    layout  => '[%d] %p %m%n',
    file    => '>>' . getcwd() . '/build_rs.log'
});
my $logger = Log::Log4perl->get_logger();

our $VERSION = '1.0.0';

# Program Configuration
my %config = (
    tmp_dir => undef,
    genome_file => undef,
    threads => 4,
    sample_size => 'all',
    rmblast_dir => undef,
    work_dir => undef
);

# Parse and validate arguments
get_and_validate_args();

# Set up environment
$logger->info("Setting up environment...");
setup_environment();

# Main execution flow
run_pipeline();

exit(0);

sub get_and_validate_args {
    GetOptions(
        'help|h'        => \my $help,
        'version|v'     => \my $version,
        'tmp=s'         => \$config{tmp_dir},
        'genome=s'      => \$config{genome_file},
        'threads=i'     => \$config{threads},
        'sample=s'      => \$config{sample_size},
        'workdir=s'     => \$config{work_dir}
    ) or pod2usage(2);

    pod2usage(1) if $help;
    if ($version) {
        print "build_RS version $VERSION\n";
        exit(0);
    }

    # Try to locate rmblast directory through multiple methods
    $config{rmblast_dir} = $ENV{RMBLAST_DIR};
    unless ($config{rmblast_dir}) {
        eval {
            use RepModelConfig;
            $config{rmblast_dir} = $RepModelConfig::configuration->{'RMBLAST_DIR'}->{'value'};
        };
    }

    # If still not found, try locating rmblastn
    unless ($config{rmblast_dir} && -x "$config{rmblast_dir}/rmblastn") {
        $config{rmblast_dir} = locate_rmblastn();
    }

    my @required = qw(tmp_dir genome_file work_dir); 
    for my $req (@required) {
        unless (defined $config{$req}) {
            $logger->error("Missing required parameter: --$req");
            die "Error: --$req is required\n";
        }
    }

    unless ($config{rmblast_dir}) {
        $logger->error("RMBLAST_DIR environment variable or configuration not found");
        die "Error: RMBLAST_DIR must be set in environment or configuration\n";
    }

    # Log configuration
    $logger->info("Configuration:");
    $logger->info("  Genome file: $config{genome_file}");
    $logger->info("  Threads: $config{threads}");
    $logger->info("  Working directory: $config{work_dir}");
    $logger->info("  RMBlast directory: $config{rmblast_dir}");
}

sub locate_rmblastn {
    $logger->info("Attempting to locate rmblastn...");
    
    # Try whereis command
    my $whereis_out = `whereis rmblastn`;
    if ($whereis_out =~ /rmblastn:\s+(\S+)/) {
        my $path = $1;
        if (-x $path) {
            $logger->info("Found rmblastn via whereis: $path");
            return dirname($path);
        }
    }
    
    # Try find command in common locations
    for my $base_dir ("/usr/local", "/usr", $ENV{HOME}, "/opt") {
        my $cmd = "find $base_dir -name rmblastn -type f 2>/dev/null";
        my $find_out = `$cmd`;
        if ($find_out) {
            chomp($find_out);
            my @paths = split(/\n/, $find_out);
            foreach my $path (@paths) {
                if (-x $path) {
                    $logger->info("Found rmblastn via find: $path");
                    return dirname($path);
                }
            }
        }
    }
    
    $logger->error("Could not locate rmblastn executable");
    die "Error: rmblastn not found in system\n";
}

sub setup_environment {
    # Create necessary directories
    for my $dir ($config{tmp_dir}, $config{work_dir}) {
        unless (-d $dir) {
            $logger->info("Creating directory: $dir");
            make_path($dir) or die "Failed to create directory $dir: $!\n";
        }
    }

    # Change to work directory
    chdir $config{work_dir} or die "Cannot change to work directory: $!\n";
    $logger->info("Changed to working directory: " . getcwd());
}

sub run_pipeline {
    $logger->info("Starting RepeatScout pipeline...");

    # Get genome size and calculate parameters
    my $genome_size = -s $config{genome_file};
    my $readable_size = sprintf("%.2f", $genome_size/1e9) . " Gb";
    $logger->info("Processing genome of size: $readable_size");

    # Calculate sampling strategy based on genome size thresholds
    my ($sample_strategy, $sample_size, $batch_size, $sample_times) = 
        determine_sampling_strategy($genome_size);
    
    $logger->info("Sampling strategy: $sample_strategy");
    $logger->info("Sample size: " . sprintf("%.2f", $sample_size/1e6) . " Mb");
    $logger->info("Batch size: " . sprintf("%.2f", $batch_size/1e3) . " Kb");
    $logger->info("Number of batches: $sample_times");

    my $lmer_size = calculate_lmer_size($genome_size);
    $logger->info("Calculated l-mer size: $lmer_size");

    # Check for RepeatScout results
    my $rs_consensus = "$config{tmp_dir}/repeats.fa";
    my $filtered_consensus = "$config{tmp_dir}/repeats.filtered.fa";

    if (-s $filtered_consensus) {
        $logger->info("Found existing filtered consensus sequences, skipping to refinement...");
        refine_consensus();
    }
    elsif (-s $rs_consensus) {
        $logger->info("Found existing RepeatScout results, skipping to filtering...");
        filter_repeats();
        refine_consensus();
    }
    else {
        # Run complete pipeline
        eval {
            # Process genome based on sampling strategy
            process_genome_by_strategy($sample_strategy, $sample_times, $batch_size);
            
            run_build_lmer_table($lmer_size);
            run_repeat_scout($lmer_size);
            filter_repeats();
            refine_consensus();
        };
        if ($@) {
            $logger->error("Pipeline failed: $@");
            die "Pipeline execution failed\n";
        }
    }

    $logger->info("Pipeline completed successfully");
}

sub calculate_lmer_size {
    my ($genome_size) = @_;
    return ceil(log($genome_size)/log(4) + 1);
}

sub run_build_lmer_table {
    my ($lmer_size) = @_;
    my $freq_file = "$config{tmp_dir}/lmer.freq";

    $logger->info("Building l-mer frequency table (l=$lmer_size)...");
    
    my $cmd = join(" ",
        "build_lmer_table",
        "-l $lmer_size",
        "-sequence $config{tmp_dir}/tmp.fa",
        "-freq $freq_file",
        "2> $config{tmp_dir}/build_lmer.log"
    );

    run_cmd($cmd);
    $logger->info("L-mer table building completed");
}

sub run_repeat_scout {
    my ($lmer_size) = @_;
    my $freq_file = "$config{tmp_dir}/lmer.freq";
    my $output = "$config{tmp_dir}/repeats.fa";

    $logger->info("Running RepeatScout...");

    my $cmd = join(" ",
        "RepeatScout",
        "-sequence $config{tmp_dir}/tmp.fa",
        "-output $output",
        "-freq $freq_file",
        "-l $lmer_size",
        "-tandemdist 50",
        "-minthresh 3",
        "2>> $config{tmp_dir}/repeatscout.log"
    );

    run_cmd($cmd);
    $logger->info("RepeatScout processing completed");
}

sub filter_repeats {
    $logger->info("Filtering repeat sequences...");

    my $input = "$config{tmp_dir}/repeats.fa";
    my $output = "$config{tmp_dir}/repeats.filtered.fa";

    $ENV{TRF_COMMAND} = which('trf');
    $ENV{RMBLAST_DIR} = $config{rmblast_dir};

    system("filter-stage-1.prl $input > $output 2> $config{tmp_dir}/filter.log") == 0
    	or die "Failed to run filter-stage-1.prl: $?\n";
    $logger->info("Repeat filtering completed");
}

sub refine_consensus {
    $logger->info("Refining consensus sequences...");

    my $input = "$config{tmp_dir}/repeats.filtered.fa";
    my $output_dir = "$config{work_dir}/refiner_output";
    my $final_output = "$config{work_dir}/consensi.fa";

    # Create required directories
    make_path($config{work_dir}) unless -d $config{work_dir};
    make_path($output_dir) unless -d $output_dir;
    
    # Ensure all input files exist
    die "Input file missing: $input\n" unless -f $input;
    my $tmp_fa = "$config{tmp_dir}/tmp.fa";
    
    # Use the new Refiner pipeline
    my $cmd = join(" ",
        "python3", "$FindBin::RealBin/Refiner/main.py",
        '--repeatscout', $input,              # RepeatScout filtered output
        '--genome', $tmp_fa,                  # Reference genome (sampled)
        '--output', $output_dir,              # Output directory for Refiner
        '--threads', $config{threads},        # Number of threads
        '--keep-temp',                        # Keep temporary files for debugging
        '2>', "$config{tmp_dir}/refiner.log"  # Log file
    );

    $logger->info("Running advanced TE consensus building with command: $cmd");
    system($cmd) == 0 
        or do {
            $logger->error("Advanced consensus refinement failed with status: $?");
            die "Advanced consensus refinement failed\n";
        };
    
    # Check for the main output file from Refiner and copy it to expected location
    my $refiner_consensus = "$output_dir/consensus_masking.fa";
    if (-f $refiner_consensus) {
        $logger->info("Copying refined consensus from $refiner_consensus to $final_output");
        system("cp '$refiner_consensus' '$final_output'") == 0
            or do {
                $logger->error("Failed to copy consensus file");
                die "Failed to copy consensus file\n";
            };
    } else {
        $logger->error("Refiner output file not found: $refiner_consensus");
        die "Refiner output file not found\n";
    }
    
    $logger->info("Advanced consensus refinement completed successfully");
}

sub which {
    my ($program) = @_;
    for my $path (split /:/, $ENV{PATH}) {
        my $file = "$path/$program";
        return $file if -x $file;
    }
    $logger->error("Cannot find $program in PATH");
    die "Cannot find $program in PATH\n";
}

sub determine_sampling_strategy {
    my ($genome_size) = @_;
    
    my $mb_400 = 400 * 1024 * 1024;    # 400MB
    my $gb_1_4 = 1.4 * 1024 * 1024 * 1024;  # 1.4GB
    my $gb_10 = 10 * 1024 * 1024 * 1024;    # 10GB
    my $kb_200 = 200 * 1024;           # 200KB
    
    if ($genome_size < $mb_400) {
        # Small genome: fragment all sequences into 200KB pieces
        my $strategy = "fragment_all";
        my $num_fragments = ceil($genome_size / $kb_200);
        return ($strategy, $genome_size, $kb_200, $num_fragments);
    }
    elsif ($genome_size >= $mb_400 && $genome_size < $gb_1_4) {
        # Medium genome: sample 600MB in 200KB chunks
        my $strategy = "sample_600mb";
        my $sample_size = 600 * 1024 * 1024;  # 600MB
        my $num_samples = $sample_size / $kb_200;  # 3000 samples
        return ($strategy, $sample_size, $kb_200, $num_samples);
    }
    elsif ($genome_size >= $gb_1_4 && $genome_size < $gb_10) {
        # Large genome: sample 800MB in 200KB chunks
        my $strategy = "sample_800mb";
        my $sample_size = 800 * 1024 * 1024;  # 800MB
        my $num_samples = $sample_size / $kb_200;  # 4000 samples
        return ($strategy, $sample_size, $kb_200, $num_samples);
    }
    else {
        # Very large genome (>10GB): sample 1GB in 200KB chunks
        my $strategy = "sample_1gb";
        my $sample_size = 1024 * 1024 * 1024;  # 1GB
        my $num_samples = int($sample_size / $kb_200);  # 5120 samples
        return ($strategy, $sample_size, $kb_200, $num_samples);
    }
}

sub process_genome_by_strategy {
    my ($strategy, $sample_times, $batch_size) = @_;
    
    $logger->info("Processing genome with strategy: $strategy");
    
    if ($strategy eq "fragment_all") {
        fragment_entire_genome($batch_size);
    }
    elsif ($strategy eq "sample_600mb" || $strategy eq "sample_800mb" || $strategy eq "sample_1gb") {
        sample_genome_chunks($sample_times, $batch_size);
    }
    else {
        die "Unknown sampling strategy: $strategy\n";
    }
}

sub fragment_entire_genome {
    my ($fragment_size) = @_;
    
    $logger->info("Fragmenting entire genome into ${fragment_size}bp pieces...");
    
    # For small genomes, we should just copy the whole genome
    # since fragmenting sequences shorter than fragment_size would result in empty output
    my $genome_size = -s $config{genome_file};
    
    if ($genome_size < $fragment_size) {
        # If genome is smaller than fragment size, just copy it as is
        $logger->info("Genome smaller than fragment size, using entire genome");
        my $cmd = "cp $config{genome_file} $config{tmp_dir}/tmp.fa";
        run_cmd($cmd);
    } else {
        # Use seqkit sliding with step size = 1/10 of window to ensure coverage
        # This creates overlapping fragments for better repeat detection
        my $step_size = int($fragment_size / 10);
        $step_size = $step_size > 0 ? $step_size : 1;
        
        my $cmd = join(" ",
            "seqkit sliding",
            "-s $step_size",           # Step size for overlap
            "-W $fragment_size",       # Window size = fragment size
            "-g",                      # Remove gap characters in sequences
            "$config{genome_file}",
            "> $config{tmp_dir}/tmp.fa"
        );
        
        run_cmd($cmd);
    }
    
    $logger->info("Genome fragmentation completed");
}

sub sample_genome_chunks {
    my ($num_samples, $chunk_size) = @_;
    
    $logger->info("Sampling $num_samples chunks of ${chunk_size}bp from genome...");
    
    # First create an index if it doesn't exist
    unless (-f "$config{genome_file}.fai") {
        run_cmd("samtools faidx $config{genome_file}");
    }
    
    # Use custom sampling function
    sample_random_chunks($config{genome_file}, $num_samples, $chunk_size, "$config{tmp_dir}/tmp.fa");
    
    $logger->info("Random chunk sampling completed");
}

sub sample_random_chunks {
    my ($genome_file, $num_samples, $chunk_size, $output_file) = @_;
    
    # Read genome index to get sequence information
    my @sequences;
    open(my $fai_fh, '<', "$genome_file.fai") or die "Cannot read fai file: $!\n";
    while (my $line = <$fai_fh>) {
        chomp $line;
        my ($seq_name, $length) = split(/\t/, $line);
        # Include all sequences, even those shorter than chunk size
        push @sequences, {name => $seq_name, length => $length};
    }
    close($fai_fh);
    
    die "No sequences long enough for sampling\n" unless @sequences;
    
    # Calculate total available length
    my $total_length = 0;
    for my $seq (@sequences) {
        if ($seq->{length} >= $chunk_size) {
            $total_length += $seq->{length} - $chunk_size + 1;  # Available positions for sampling
        } else {
            $total_length += 1;  # Can use the whole sequence as one sample
        }
    }
    
    $logger->info("Total sequences: " . scalar(@sequences));
    $logger->info("Total available positions: $total_length");
    
    # Generate random sampling positions
    my @samples;
    my $attempts = 0;
    my $max_attempts = $num_samples * 10;
    
    while (@samples < $num_samples && $attempts < $max_attempts) {
        $attempts++;
        
        # Randomly select a sequence weighted by length
        my $rand_pos = int(rand($total_length));
        my $cumulative = 0;
        my $selected_seq;
        
        for my $seq (@sequences) {
            my $available_positions;
            if ($seq->{length} >= $chunk_size) {
                $available_positions = $seq->{length} - $chunk_size + 1;
            } else {
                $available_positions = 1;  # Can only take the whole sequence
            }
            $cumulative += $available_positions;
            if ($rand_pos < $cumulative) {
                $selected_seq = $seq;
                last;
            }
        }
        
        next unless $selected_seq;
        
        # Handle position selection based on sequence length
        my ($start_pos, $end_pos);
        if ($selected_seq->{length} >= $chunk_size) {
            # Random position within selected sequence
            my $max_start = $selected_seq->{length} - $chunk_size;
            $start_pos = int(rand($max_start)) + 1;  # 1-based coordinates
            $end_pos = $start_pos + $chunk_size - 1;
        } else {
            # For sequences shorter than chunk size, take the whole sequence
            $start_pos = 1;
            $end_pos = $selected_seq->{length};
        }
        
        # Create sample entry
        my $sample_id = sprintf("sample_%04d_%s_%d_%d", 
                               scalar(@samples), $selected_seq->{name}, $start_pos, $end_pos);
        
        push @samples, {
            id => $sample_id,
            seq => $selected_seq->{name},
            start => $start_pos,
            end => $end_pos
        };
        
        if (@samples % 500 == 0) {
            $logger->info("Generated " . scalar(@samples) . " / $num_samples samples");
        }
    }
    
    $logger->info("Generated " . scalar(@samples) . " samples total");
    
    # Extract sequences using samtools faidx
    open(my $out_fh, '>', $output_file) or die "Cannot create output file: $!\n";
    
    for my $sample (@samples) {
        my $region = "$sample->{seq}:$sample->{start}-$sample->{end}";
        my $seq_data = `samtools faidx $genome_file $region`;
        
        if ($seq_data) {
            # Replace header with our sample ID
            $seq_data =~ s/^>[^\n]+/>$sample->{id}/;
            print $out_fh $seq_data;
        }
    }
    
    close($out_fh);
    $logger->info("Sequence extraction completed");
}

sub run_cmd {
    my $cmd = shift;
    $cmd =~ s/[`;\$]/\\$&/g;
    $logger->info("Executing command: $cmd");
    
    my $output = `$cmd 2>&1`;
    my $exit_code = $? >> 8;
    
    if ($exit_code != 0) {
        $logger->error("Command failed with exit code: $exit_code");
        $logger->error("Command output:");
        $logger->error($output);
        die "Command execution failed\n";
    }
    
    $logger->debug("Command completed successfully");
    return $output;
}

