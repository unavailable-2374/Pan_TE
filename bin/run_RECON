#!/usr/bin/env perl
use strict;
use warnings;
use File::Path qw(make_path remove_tree);
use File::Spec;
use File::Basename qw(dirname basename);
use Cwd qw(getcwd);
use constant {
    MIN_THREADS => 1,
    DEFAULT_EVALUE => '1e-5',
    BLAST_DB_TYPE => 'nucl',
};

# Utility functions
sub min { return $_[0] < $_[1] ? $_[0] : $_[1]; }
sub max { return $_[0] > $_[1] ? $_[0] : $_[1]; }

die "Usage: $0 round_num threads genome_file genome_size\n"
    unless @ARGV == 4;

my ($round_num, $threads, $genome_file, $genome_size) = @ARGV;

die "Round number must be positive\n" unless $round_num > 0;
die "Threads must be at least " . MIN_THREADS . "\n" unless $threads >= MIN_THREADS;
die "Genome file $genome_file not found\n" unless -f $genome_file;
die "Invalid genome size\n" unless $genome_size =~ /^\d+$/;

# Convert genome_file to absolute path before any operations
my $abs_genome_file = File::Spec->rel2abs($genome_file);

my $cpu_threads = int($threads/4);
$cpu_threads = MIN_THREADS if $cpu_threads < MIN_THREADS;

# Use Refiner-generated masked genome directly without splitting
print "Using Refiner-generated masked genome directly without splitting\n";

# Step 1: Extract unmasked regions first
print "\nStep 1: Extracting unmasked regions from masked genome...\n";
my $unmasked_file = extract_unmasked_regions($abs_genome_file);

if (!-s $unmasked_file || -s $unmasked_file < 1000) {
    die "ERROR: No significant unmasked regions found in $abs_genome_file\n";
}

# Step 2: Process unmasked regions directly without splitting
my $unmasked_size = -s $unmasked_file;
print "\nStep 2: Processing unmasked regions directly...\n";
print "Unmasked regions file size: " . sprintf("%.1f MB\n", $unmasked_size / (1024 * 1024));

# Always process as single file without splitting
my $tmp_dir = "round-$round_num";
make_path($tmp_dir) unless -d $tmp_dir;
chdir $tmp_dir or die "Cannot change to directory $tmp_dir: $!\n";

run_single_file_recon($unmasked_file, $threads);

chdir "..";

my $ok_file = "round-${round_num}.ok";
open(my $fh_ok, '>', $ok_file) or die "Cannot create $ok_file: $!\n";
close $fh_ok;

exit 0;


sub process_blast_db {
    my ($threads,$genome_file) = @_;
    return if -e "msp.out";
    
    # No need for translation table as IDs already contain genomic coordinates
    # The unmasked regions file already has proper IDs like chr4_164248806_164248906
    
    print "Creating BLAST database from unmasked regions\n";
    process_unmasked_file_for_blast("tmp.fa");
    
    run_cmd("makeblastdb -in DB.fa -dbtype " . BLAST_DB_TYPE . 
            " -parse_seqids -out DB");
    run_cmd("blastn -query DB.fa -out recon.tbl -db DB -outfmt 6 " .
            "-evalue " . DEFAULT_EVALUE . " -num_threads $threads");
    run_cmd("Tbl2Msp recon.tbl > msp.out");
    
    create_seq_name_list();
}

sub run_recon_pipeline {
    for my $dir ('images', 'summary') {
        make_path($dir) unless -d $dir;
    }
    
    run_cmd("imagespread seq_name.list msp.out > imagespread.log 2> imagespread.log");
    move_gmon("imagespread");
    
    run_cmd("sort -k 3,3 -k 4n,4n -k 5nr,5nr images/spread1 > images/images_sorted");
    unlink glob "images/spread*";
    
    process_element_definition();
    
    process_element_redefinition();
    
    process_edge_redefinition();
    
    run_cmd("famdef seq_name.list > famdef.log 2> famdef.log");
    move_gmon("famdef");
}

sub process_element_definition {
    remove_tree('ele_def_res');
    make_path('ele_def_res');
    
    run_cmd("eledef seq_name.list msp.out single > eledef.log 2> eledef.log");
    move_gmon("eledef");
}

sub process_element_redefinition {
    remove_tree('ele_redef_res');
    make_path('ele_redef_res');
    
    create_symlinks('ele_def_res', 'ele_redef_res');
    run_cmd("eleredef seq_name.list > eleredef.log  2> eleredef.log");
    move_gmon("eleredef");
    remove_symlinks();
}

sub process_edge_redefinition {
    remove_tree('edge_redef_res');
    make_path('edge_redef_res');
    
    create_symlinks('ele_redef_res', 'edge_redef_res');
    run_cmd("edgeredef seq_name.list > edgeredef.log 2> edgeredef.log");
    move_gmon("edgeredef");
    remove_symlinks();
    
    create_symlinks('edge_redef_res', undef);
}

# Translation table no longer needed as we embed genomic coordinates directly in sequence IDs


sub extract_unmasked_regions {
    my ($masked_file) = @_;
    
    print "Extracting unmasked regions from: $masked_file\n";
    
    my $output_file = "unmasked_regions.fa";
    
    open(my $fh_in, '<', $masked_file) 
        or die "Cannot open $masked_file: $!\n";
    open(my $fh_out, '>', $output_file) 
        or die "Cannot open $output_file: $!\n";
    
    my $current_seq = "";
    my $current_header = "";
    my $total_seqs = 0;
    my $total_regions = 0;
    my $start_time = time();
    
    # Buffer for batch writing
    my $output_buffer = "";
    my $max_buffer_size = 1024 * 1024;  # 1MB buffer
    
    while (my $line = <$fh_in>) {
        chomp $line;
        if($line =~ /^>(.*)/) {
            # Process previous sequence if exists
            if ($current_header && $current_seq) {
                my $regions_found = extract_and_map_regions(\$output_buffer, $current_header, $current_seq);
                $total_regions += $regions_found;
                $total_seqs++;
                
                # Flush buffer if it's getting large
                if (length($output_buffer) > $max_buffer_size) {
                    print $fh_out $output_buffer;
                    $output_buffer = "";
                }
            }
            
            # Start new sequence
            $current_header = $1;
            $current_seq = "";
        } else {
            $current_seq .= $line;
        }
    }
    
    # Process last sequence
    if ($current_header && $current_seq) {
        my $regions_found = extract_and_map_regions(\$output_buffer, $current_header, $current_seq);
        $total_regions += $regions_found;
        $total_seqs++;
    }
    
    # Flush remaining buffer
    print $fh_out $output_buffer if $output_buffer;
    
    close($fh_in);
    close($fh_out);
    
    my $elapsed = time() - $start_time;
    print "Processed $total_seqs sequences, extracted $total_regions unmasked regions (>=50bp) in ${elapsed}s\n";
    
    return $output_file;
}

sub process_unmasked_file_for_blast {
    my ($unmasked_file) = @_;
    
    print "Preparing BLAST database from: $unmasked_file\n";
    
    # Convert unmasked regions to BLAST format with gi numbers
    open(my $fh_in, '<', $unmasked_file) or die "Cannot open $unmasked_file: $!\n";
    open(my $fh_out, '>', "DB.fa") or die "Cannot open DB.fa: $!\n";
    
    my $counter = 1;
    while (my $line = <$fh_in>) {
        if ($line =~ /^>(.*)/) {
            my $header = $1;
            # Convert chr4_164248806_164248906 format to BLAST format
            print $fh_out ">gi|$counter gi|$header\n";
            $counter++;
        } else {
            print $fh_out $line;
        }
    }
    
    close($fh_in);
    close($fh_out);
    
    my $seq_count = $counter - 1;
    print "Created BLAST database with $seq_count unmasked region sequences\n";
}

sub extract_and_map_regions {
    my ($buffer_ref, $header, $sequence) = @_;
    
    # Parse the header to extract genomic coordinates
    # Expected format: sample_0000_chr4_164248806_164453605 preliminary masked
    my ($chr, $start_pos, $end_pos);
    if ($header =~ /sample_\d+_(chr\w+)_(\d+)_(\d+)/) {
        $chr = $1;
        $start_pos = $2;
        $end_pos = $3;
    } else {
        # Fallback: use the whole header as chromosome name
        $chr = $header;
        $start_pos = 1;
        $end_pos = length($sequence);
    }
    
    # Split sequence into unmasked regions (uppercase ATCG only)
    my @regions;
    
    # Match only uppercase ATCG regions (not N, not lowercase)
    while ($sequence =~ /([ATCG]+)/g) {
        my $match = $1;
        my $relative_start = $-[0];  # 0-based position in the sequence
        my $relative_end = $+[0];     # 0-based exclusive end
        
        if (length($match) >= 50) {  # Only keep regions >= 50bp
            # Calculate actual genomic coordinates
            my $actual_start = $start_pos + $relative_start;
            my $actual_end = $start_pos + $relative_end - 1;  # Convert to inclusive end
            
            push @regions, {
                chr => $chr,
                start => $actual_start,
                end => $actual_end,
                seq => $match
            };
        }
    }
    
    # Output each unmasked region with correct genomic coordinates
    foreach my $region (@regions) {
        # Create ID that reflects true genomic position
        my $region_id = $region->{chr} . "_" . $region->{start} . "_" . $region->{end};
        $$buffer_ref .= ">" . $region_id . "\n";
        $$buffer_ref .= $region->{seq} . "\n";
    }
    
    # Return number of regions found for statistics
    return scalar(@regions);
}

# Functions removed: process_masked_sequence and convert_to_blast_format
# No longer needed with the new unmasked region extraction approach

sub create_seq_name_list {
    run_cmd("grep '>' DB.fa | wc -l > seq_name.list");
    open(my $in, '<', 'DB.fa') or die "Can't open DB.fa: $!";
    open(my $out, '>>', 'seq_name.list') or die "Can't open seq_name.list: $!";

    my @headers;
    while (<$in>) {
        if (/^>(.*)/) {
            push @headers, (split /\s+/, $1)[0];
        }
    }
    print $out "$_\n" for sort @headers;

    close $in;
    close $out;
}

sub create_symlinks {
    my ($src, $dst) = @_;
    remove_tree("tmp");
    remove_tree("tmp2");
    symlink($src, 'tmp') or die "Cannot create symlink tmp: $!\n";
    symlink($dst, 'tmp2') or die "Cannot create symlink tmp2: $!\n" if $dst;
}

sub remove_symlinks {
    remove_tree("tmp");
    remove_tree("tmp2");
}

sub move_gmon {
    my $prefix = shift;
    if (-f "gmon.out") {
        rename("gmon.out", "${prefix}-gmon.out") 
            or die "Cannot rename gmon.out: $!\n";
    }
}

sub build_final_output {
    my ($threads) = @_;
    # Get absolute path to the genome file
    my $main_output_dir = File::Spec->rel2abs("../..");
    my $genome_file = File::Spec->catfile($main_output_dir, "genome", "genome.fa");
    run_cmd("build_for_RECON ./ $genome_file $threads");
}

# Removed functions for simplified direct processing:
# - read_annotation_ratio_from_refiner: No sampling needed
# - calculate_annotation_ratio: No sampling needed
# - determine_split_count_for_unmasked: No longer splitting files
# - split_unmasked_file: Processing entire unmasked_regions.fa directly
# - run_multi_split_recon: No parallel split processing needed
# - start_blast_phase/start_recon_phase: No forking required
# - merge_recon_results: No merging of multiple rounds

sub run_single_file_recon {
    my ($genome_file, $threads) = @_;
    
    # Process single file in current directory
    # genome_file is the unmasked regions file
    my $abs_genome_file;
    if (File::Spec->file_name_is_absolute($genome_file)) {
        $abs_genome_file = $genome_file;
    } else {
        $abs_genome_file = File::Spec->rel2abs("../$genome_file");
    }
    
    run_cmd("ln -sf $abs_genome_file tmp.fa");
    
    # Run complete BLAST and RECON pipeline
    # Note: process_blast_db now expects pre-extracted unmasked regions
    process_blast_db($threads, $abs_genome_file);
    run_recon_pipeline();
    build_final_output($threads);
}

sub run_cmd {
    my $cmd = shift;
    $cmd =~ s/[`;\$]/\\$&/g;
    system($cmd) == 0 or die "Failed to execute: $cmd\n";
}
