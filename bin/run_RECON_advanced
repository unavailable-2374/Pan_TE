#!/usr/bin/env perl

use strict;
use warnings;
use FindBin qw($Bin);
use lib "$Bin/../lib";
use File::Path qw(make_path);
use Cwd qw(getcwd abs_path);
use Time::HiRes qw(time);

# Import modular components
use RECON::Config;
use RECON::Logger;
use RECON::Utils;
use RECON::Core;
use RECON::MaskedTrack;
use RECON::SamplingTrack;

# ============================================================================
# MAIN PIPELINE
# ============================================================================

sub main {
    # Initialize fresh logger for new run
    init_logger();
    
    # Check if pipeline is already completed
    if (check_pipeline_completion()) {
        log_message("INFO", "Pipeline already completed", "skipping execution, RECON.ok found");
        print "RECON pipeline already completed successfully. Remove RECON.ok to rerun.\n";
        exit 0;
    }
    
    # Initialize pipeline
    log_step_start("PIPELINE INITIALIZATION", "Advanced RECON pipeline with dual-track processing");
    
    # Parse and validate configuration
    my $config = parse_arguments();
    $config = find_input_files($config);
    
    log_message("INFO", "Command line arguments", 
                "threads=$config->{threads}, genome=$config->{genome_file}, " .
                "size=$config->{genome_size}");
    
    log_message("INFO", "Resource allocation", 
                "threads=$config->{threads}, cpu_threads=$config->{cpu_threads}");
    
    # Check required tools
    check_required_tools();
    
    # Create working directory structure
    setup_working_directory($config);
    
    log_step_end("PIPELINE INITIALIZATION", 1, "Ready to start RECON processing");
    
    # Execute pipeline based on processing mode
    my $success = 0;
    
    if ($config->{processing_mode} eq 'single_track') {
        $success = run_single_track_pipeline($config);
    } else {
        $success = run_dual_track_pipeline($config);
    }
    
    if ($success) {
        my %execution_results = ();
        if ($config->{processing_mode} eq 'dual_track') {
            # Get the actual execution results for dual-track reporting using absolute paths
            my $current_wd = getcwd();
            my $masked_consensi = "$current_wd/masked_track/consensi.fa";
            $execution_results{masked_success} = (-f $masked_consensi && -s $masked_consensi);
            
            $execution_results{sampling_success} = 0;
            for my $round_dir (glob "$current_wd/sampling_track/round_*") {
                my $sampling_consensi = "$round_dir/consensi.fa";
                if (-f $sampling_consensi && -s $sampling_consensi) {
                    $execution_results{sampling_success} = 1;
                    last;
                }
            }
            
            # Debug: Log the actual execution results with paths
            log_message("DEBUG", "Final execution state verification",
                        "working_dir=$current_wd, " .
                        "masked_file=$masked_consensi, " .
                        "masked_exists=" . (-f $masked_consensi ? "yes" : "no") . ", " .
                        "masked_size=" . ((-s $masked_consensi) || 0) . ", " .
                        "masked_success=" . ($execution_results{masked_success} ? "true" : "false") . ", " .
                        "sampling_success=" . ($execution_results{sampling_success} ? "true" : "false") . ", " .
                        "overall_success=" . ($success ? "true" : "false"));
        }
        generate_final_report($config, \%execution_results);
        create_completion_marker($config);
    } else {
        log_message("ERROR", "Pipeline failed", "no successful tracks completed");
        print "ERROR: RECON pipeline failed - no results generated\n";
        exit 1;  # Exit with error code for Pan_TE
    }
    
    return $success;
}

sub run_single_track_pipeline {
    my ($config) = @_;
    
    log_step_start("SINGLE TRACK MODE", "Small genome - masked track processing");
    
    log_message("INFO", "Genome mode", "Single-track (small genome with masked track processing)");
    log_message("INFO", "Input file", "genome=$config->{genome_file}");
    
    # Use masked track processing for small genomes to get high-quality consensus
    # This extracts unmasked regions and uses gi|N naming format
    my $success = run_masked_track_independent(
        $config->{genome_file},
        getcwd(),
        $config->{threads},
        $config->{cpu_threads},
        $config->{genome_size}
    );
    
    log_step_end("SINGLE TRACK MODE", $success, 
                 $success ? "Single track (masked track) completed" : "Single track (masked track) failed");
    
    return $success;
}

sub run_dual_track_pipeline {
    my ($config) = @_;
    
    log_step_start("DUAL TRACK MODE", "Large genome - independent dual-track processing");
    
    log_message("INFO", "Genome mode", "Dual-track (large genome)");
    log_message("INFO", "Input files", 
                "masked_genome=$config->{genome_file}, original=$config->{genome_file}");
    
    if (@{$config->{bed_files}}) {
        log_message("INFO", "BED exclusion files", 
                    scalar(@{$config->{bed_files}}) . " files: " . 
                    join(", ", @{$config->{bed_files}}));
    }
    
    # Track 1: Masked genome processing
    my $masked_success = run_track_1($config);
    
    # Track 2: Sampling with progressive masking
    my $sampling_success = run_track_2($config);
    
    my $overall_success = $masked_success || $sampling_success;
    
    my $status_msg = "";
    if ($masked_success && $sampling_success) {
        $status_msg = "Both tracks completed successfully";
    } elsif ($masked_success) {
        $status_msg = "Masked track completed, sampling track failed";
    } elsif ($sampling_success) {
        $status_msg = "Sampling track completed, masked track failed";
    } else {
        $status_msg = "Both tracks failed";
    }
    
    log_step_end("DUAL TRACK MODE", $overall_success, $status_msg);
    
    return $overall_success;
}

sub run_track_1 {
    my ($config) = @_;
    
    log_step_start("TRACK 1 - MASKED GENOME", "Processing masked genome for high-quality consensus");
    
    make_path("masked_track");
    
    my $success = 0;
    eval {
        $success = run_masked_track_independent(
            $config->{genome_file},
            "masked_track",
            $config->{threads},
            $config->{cpu_threads},
            $config->{genome_size}
        );
    };
    
    if ($@) {
        log_message("ERROR", "Masked track failed", "error=$@");
        $success = 0;
    }
    
    # Verify that actual results exist
    my $consensi_file = "masked_track/consensi.fa";
    my $has_results = (-f $consensi_file && -s $consensi_file > 1000);
    
    if ($success && $has_results) {
        my $count = `grep -c '^>' $consensi_file 2>/dev/null || echo 0`;
        chomp $count;
        my $size = -s $consensi_file;
        log_message("INFO", "Masked track results verified", 
                   "sequences=$count, size=$size bytes");
    } elsif ($success && !$has_results) {
        log_message("WARN", "Masked track checkpoint found but no valid results", 
                   "consensi.fa missing or too small");
        $success = 0;
    }
    
    log_step_end("TRACK 1 - MASKED GENOME", $success, 
                 $success ? "Masked genome processing completed" : "Masked genome processing failed");
    
    return $success;
}

sub run_track_2 {
    my ($config) = @_;
    
    log_step_start("TRACK 2 - SAMPLING", "Multi-round sampling with progressive masking");
    
    make_path("sampling_track");
    
    # Find initial consensus from masked track
    my $masked_consensi = "masked_track/consensi.fa";
    $masked_consensi = abs_path($masked_consensi) if -s $masked_consensi;
    
    log_message("INFO", "Starting sampling track", 
                "initial_consensi=" . (-s $masked_consensi ? $masked_consensi : "none"));
    
    my $success = 0;
    eval {
        # Use original genome for sampling, not masked genome
        my $sampling_genome = $config->{original_genome_file} || $config->{genome_file};
        run_sampling_track_independent(
            $sampling_genome,
            $config->{bed_files},
            $masked_consensi,
            "sampling_track",
            $config->{threads},
            $config->{cpu_threads},
            $config->{original_genome_size} || $config->{genome_size}
        );
        $success = 1;
    };
    
    if ($@) {
        log_message("WARN", "Sampling track failed", "error=$@");
        log_message("INFO", "Fallback strategy", "Masked track results are still available");
        $success = 0;
    }
    
    log_step_end("TRACK 2 - SAMPLING", $success, 
                 $success ? "Sampling track completed successfully" : 
                           "Sampling track failed, using masked track only");
    
    return $success;
}

sub generate_final_report {
    my ($config, $execution_results) = @_;
    
    log_step_start("PIPELINE SUMMARY", "Generating final statistics and report");
    
    my $total_elapsed = time() - $RECON::Logger::PIPELINE_START_TIME;
    
    if ($config->{processing_mode} eq 'single_track') {
        generate_single_track_report($config);
    } else {
        generate_dual_track_report($config, $execution_results);
    }
    
    log_message("INFO", "Pipeline completed", 
                sprintf("total_time=%.1f seconds (%.1f minutes)", 
                        $total_elapsed, $total_elapsed/60));
    
    log_resource_usage("pipeline_end");
    
    printf "\nRECON pipeline completed in %.1f seconds (%.1f minutes)\n", 
           $total_elapsed, $total_elapsed/60;
}

sub generate_single_track_report {
    my ($config) = @_;
    
    log_message("INFO", "Pipeline mode", "Single-track (small genome with masked track processing)");
    
    if (-s "consensi.fa") {
        my $count = `grep -c '^>' consensi.fa`;
        chomp $count;
        my $size = -s "consensi.fa";
        log_message("INFO", "Final results", "sequences=$count, file_size=${size} bytes");
        print "Generated $count consensus sequences (using masked track processing)\n";
        
        # Report unmasked region extraction statistics if available
        if (-f "unmasked_extraction.ok") {
            my $extraction_info = `tail -2 unmasked_extraction.ok | head -1`;
            chomp $extraction_info;
            log_message("INFO", "Unmasked region extraction", $extraction_info);
        }
    } else {
        log_message("WARN", "No consensus sequences generated", "consensi.fa missing or empty");
        print "Warning: No consensus sequences generated\n";
    }
}

sub generate_dual_track_report {
    my ($config, $execution_results) = @_;
    
    log_message("INFO", "Pipeline mode", "Dual-track (large genome)");
    
    # Use absolute paths to ensure file access regardless of working directory
    my $current_wd = getcwd();
    my $masked_consensi = "$current_wd/masked_track/consensi.fa";
    my $sampling_dir = "$current_wd/sampling_track";
    
    # Use execution results if available, otherwise fall back to file detection
    my $masked_success = $execution_results ? $execution_results->{masked_success} : 
                        (-f $masked_consensi && -s $masked_consensi);
    my $sampling_success = $execution_results ? $execution_results->{sampling_success} : 0;
    
    # Report masked track results
    my ($masked_count, $masked_size) = (0, 0);
    if ($masked_success && -f $masked_consensi && -s $masked_consensi) {
        $masked_count = `grep -c '^>' '$masked_consensi' 2>/dev/null || echo 0`;
        chomp $masked_count;
        $masked_size = -s $masked_consensi;
        log_message("INFO", "Masked track results", "sequences=$masked_count, size=${masked_size} bytes");
        print "Masked track: $masked_count consensus sequences\n";
    } else {
        log_message("WARN", "Masked track failed", "no consensus sequences generated");
        print "Masked track: 0 consensus sequences (failed)\n";
    }
    
    # Report sampling track results
    my ($sampling_rounds, $sampling_consensi, $sampling_total_size) = (0, 0, 0);
    
    if (-d $sampling_dir) {
        for my $round_dir (glob "$sampling_dir/round_*") {
            my $consensi_file = "$round_dir/consensi.fa";
            if (-f $consensi_file && -s $consensi_file) {
                $sampling_rounds++;
                my $count = `grep -c '^>' '$consensi_file' 2>/dev/null || echo 0`;
                chomp $count;
                $sampling_consensi += $count;
                $sampling_total_size += -s $consensi_file;
            }
        }
        
        if ($sampling_rounds > 0) {
            log_message("INFO", "Sampling track results", 
                       "rounds=$sampling_rounds, total_sequences=$sampling_consensi, " .
                       "total_size=${sampling_total_size} bytes");
        } else {
            log_message("WARN", "Sampling track failed", "no rounds completed successfully");
        }
    } else {
        log_message("WARN", "Sampling track not started", "directory not found");
    }
    
    print "Sampling track: $sampling_rounds rounds, $sampling_consensi total consensus sequences\n";
    
    my $total_sequences = $masked_count + $sampling_consensi;
    my $total_size = $masked_size + $sampling_total_size;
    log_message("INFO", "Combined results", "total_sequences=$total_sequences, total_size=${total_size} bytes");
}

sub create_completion_marker {
    my ($config) = @_;
    
    # Create completion marker
    open(my $fh_ok, '>', "RECON.ok") or die "Cannot create RECON.ok: $!\n";
    print $fh_ok "Completed at " . localtime() . "\n";
    my $mode_description = $config->{processing_mode} eq 'single_track' ? 
                          "single_track (using masked track processing)" : 
                          $config->{processing_mode};
    print $fh_ok "Processing mode: $mode_description\n";
    print $fh_ok "Genome class: $config->{genome_class}\n";
    print $fh_ok "Threads: $config->{threads}\n";
    close $fh_ok;
    
    log_message("INFO", "Pipeline completion marker created", "file=RECON.ok");
    log_step_end("PIPELINE SUMMARY", 1, "Advanced RECON pipeline finished successfully");
}

sub setup_working_directory {
    my ($config) = @_;
    
    # Ensure we have a clean working environment
    # (Optional: could add cleanup logic here)
}

sub check_pipeline_completion {
    # Check if RECON.ok exists and validate results
    return 0 unless -f "RECON.ok";
    
    log_message("INFO", "Found completion marker", "file=RECON.ok");
    
    # Read the checkpoint file to determine mode
    my $mode = 'unknown';
    my $checkpoint_time = (stat("RECON.ok"))[9];
    
    if (open(my $fh, '<', "RECON.ok")) {
        while (my $line = <$fh>) {
            if ($line =~ /Processing mode: (\S+)/) {
                $mode = $1;
                last;
            }
        }
        close $fh;
    }
    
    log_message("INFO", "Checking completion status", "mode=$mode");
    
    # Validate based on processing mode
    if ($mode eq 'single_track') {
        # Check for single track results
        if (-f "consensi.fa" && -s "consensi.fa" > 100) {
            my $consensi_time = (stat("consensi.fa"))[9];
            if ($consensi_time >= $checkpoint_time - 10) {  # Allow 10 second tolerance
                log_message("INFO", "Single track results valid", "consensi.fa exists and is recent");
                return 1;
            } else {
                log_message("WARN", "Checkpoint newer than results", 
                           "consensi.fa may be stale, regenerating");
                return 0;
            }
        } else {
            log_message("WARN", "Single track results missing", "consensi.fa not found or empty");
            return 0;
        }
    } elsif ($mode eq 'dual_track') {
        # Check for dual track results
        my $masked_ok = 0;
        my $sampling_ok = 0;
        
        if (-f "masked_track/consensi.fa" && -s "masked_track/consensi.fa" > 100) {
            my $masked_time = (stat("masked_track/consensi.fa"))[9];
            $masked_ok = ($masked_time >= $checkpoint_time - 10);
            log_message("INFO", "Masked track status", 
                       "valid=" . ($masked_ok ? "yes" : "no") . 
                       ", size=" . (-s "masked_track/consensi.fa"));
        }
        
        # Check sampling track
        for my $round_dir (glob "sampling_track/round_*") {
            my $consensi_file = "$round_dir/consensi.fa";
            if (-f $consensi_file && -s $consensi_file > 100) {
                my $sampling_time = (stat($consensi_file))[9];
                if ($sampling_time >= $checkpoint_time - 10) {
                    $sampling_ok = 1;
                    log_message("INFO", "Sampling track valid", "round=$round_dir");
                    last;
                }
            }
        }
        
        if ($masked_ok || $sampling_ok) {
            log_message("INFO", "Dual track results valid", 
                       "masked=$masked_ok, sampling=$sampling_ok");
            return 1;
        } else {
            log_message("WARN", "Dual track results incomplete", 
                       "regenerating pipeline");
            return 0;
        }
    } else {
        log_message("WARN", "Unknown processing mode in checkpoint", "mode=$mode");
        return 0;
    }
}

# ============================================================================
# EXECUTION
# ============================================================================

# Execute main pipeline
my $success = main();
exit($success ? 0 : 1);

__END__

=head1 NAME

run_RECON_advanced_modular - Modular RECON pipeline for transposable element discovery

=head1 SYNOPSIS

    run_RECON_advanced_modular threads genome_file genome_size [options]

=head1 DESCRIPTION

A modular, maintainable implementation of the advanced RECON pipeline with
dual-track processing for comprehensive transposable element discovery.

The pipeline automatically determines the optimal processing strategy based on
genome size and available resources, using either single-track processing for
small genomes or dual-track processing for large genomes.

=head1 ARCHITECTURE

The modular architecture consists of:

- RECON::Config    - Configuration and argument parsing
- RECON::Logger    - Consistent logging and progress tracking  
- RECON::Utils     - Common utility functions
- RECON::Core      - Core RECON algorithm implementation
- RECON::MaskedTrack   - High-quality consensus from masked genomes
- RECON::SamplingTrack - Progressive sampling with adaptive stopping

=head1 AUTHORS

Pan_TE Development Team

=head1 COPYRIGHT

Copyright (C) 2025. Licensed under GPL v3.0.

=cut